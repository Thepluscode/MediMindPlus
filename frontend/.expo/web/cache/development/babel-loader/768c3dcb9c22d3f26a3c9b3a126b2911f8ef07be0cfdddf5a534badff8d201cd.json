{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport axios, { AxiosRequestConfig } from 'axios';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport { store } from \"../store/store\";\nimport { setTokens } from \"../store/slices/authSlice\";\nexport var API_BASE_URL = __DEV__ ? 'http://localhost:3000/api' : 'https://api.medimind.app/api';\nvar apiService = axios.create({\n  baseURL: API_BASE_URL,\n  timeout: 30000,\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\napiService.interceptors.request.use(function () {\n  var _ref = _asyncToGenerator(function* (config) {\n    var token = yield AsyncStorage.getItem('authToken');\n    if (token && config.headers) {\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n    return config;\n  });\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}(), function (error) {\n  return Promise.reject(error);\n});\napiService.interceptors.response.use(function (response) {\n  return response;\n}, function () {\n  var _ref2 = _asyncToGenerator(function* (error) {\n    var _error$response;\n    var originalRequest = error.config;\n    if (((_error$response = error.response) == null ? void 0 : _error$response.status) === 401 && originalRequest && !originalRequest._retry) {\n      originalRequest._retry = true;\n      try {\n        var refreshToken = yield AsyncStorage.getItem('refreshToken');\n        if (refreshToken) {\n          var response = yield axios.post(`${API_BASE_URL}/auth/refresh`, {\n            refreshToken: refreshToken\n          });\n          var _response$data = response.data,\n            token = _response$data.token,\n            newRefreshToken = _response$data.refreshToken;\n          if (token && newRefreshToken) {\n            yield AsyncStorage.setItem('authToken', token);\n            yield AsyncStorage.setItem('refreshToken', newRefreshToken);\n            store.dispatch(setTokens({\n              token: token,\n              refreshToken: newRefreshToken\n            }));\n            if (originalRequest.headers) {\n              originalRequest.headers.Authorization = `Bearer ${token}`;\n            }\n            return apiService(originalRequest);\n          }\n        }\n      } catch (refreshError) {\n        yield AsyncStorage.multiRemove(['authToken', 'refreshToken']);\n        console.log('Session expired, please log in again');\n      }\n    }\n    return Promise.reject(error);\n  });\n  return function (_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}());\nvar typedApiService = {\n  get: function get(url, config) {\n    return apiService.get(url, config);\n  },\n  post: function post(url, data, config) {\n    return apiService.post(url, data, config);\n  },\n  put: function put(url, data, config) {\n    return apiService.put(url, data, config);\n  },\n  delete: function _delete(url, config) {\n    return apiService.delete(url, config);\n  },\n  patch: function patch(url, data, config) {\n    return apiService.patch(url, data, config);\n  }\n};\nexport default typedApiService;","map":{"version":3,"names":["axios","AxiosRequestConfig","AsyncStorage","store","setTokens","API_BASE_URL","__DEV__","apiService","create","baseURL","timeout","headers","interceptors","request","use","_ref","_asyncToGenerator","config","token","getItem","Authorization","_x","apply","arguments","error","Promise","reject","response","_ref2","_error$response","originalRequest","status","_retry","refreshToken","post","_response$data","data","newRefreshToken","setItem","dispatch","refreshError","multiRemove","console","log","_x2","typedApiService","get","url","put","delete","patch"],"sources":["/Users/theophilusogieva/Downloads/medimind/frontend/src/services/apiService.ts"],"sourcesContent":["import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport { store } from '../store/store';\nimport { setTokens } from '../store/slices/authSlice';\nimport { AuthResponse } from '../types/models/user';\n\nexport const API_BASE_URL = __DEV__ \n  ? 'http://localhost:3000/api' \n  : 'https://api.medimind.app/api';\n\n// Extend AxiosRequestConfig to include _retry flag\ndeclare module 'axios' {\n  export interface AxiosRequestConfig {\n    _retry?: boolean;\n  }\n}\n\n// Create axios instance with type annotations\nconst apiService: AxiosInstance = axios.create({\n  baseURL: API_BASE_URL,\n  timeout: 30000,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\n// Request interceptor to add auth token\napiService.interceptors.request.use(\n  async (config: AxiosRequestConfig) => {\n    const token = await AsyncStorage.getItem('authToken');\n    if (token && config.headers) {\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n    return config;\n  },\n  (error: AxiosError) => {\n    return Promise.reject(error);\n  }\n);\n\n// Response interceptor to handle token refresh\napiService.interceptors.response.use(\n  (response: AxiosResponse) => response,\n  async (error: AxiosError) => {\n    const originalRequest = error.config;\n\n    if (error.response?.status === 401 && originalRequest && !originalRequest._retry) {\n      originalRequest._retry = true;\n\n      try {\n        const refreshToken = await AsyncStorage.getItem('refreshToken');\n        if (refreshToken) {\n          const response = await axios.post<AuthResponse>(\n            `${API_BASE_URL}/auth/refresh`, \n            { refreshToken }\n          );\n\n          const { token, refreshToken: newRefreshToken } = response.data;\n\n          if (token && newRefreshToken) {\n            // Update tokens in storage and store\n            await AsyncStorage.setItem('authToken', token);\n            await AsyncStorage.setItem('refreshToken', newRefreshToken);\n            store.dispatch(setTokens({ token, refreshToken: newRefreshToken }));\n\n            // Retry original request\n            if (originalRequest.headers) {\n              originalRequest.headers.Authorization = `Bearer ${token}`;\n            }\n            return apiService(originalRequest);\n          }\n        }\n      } catch (refreshError) {\n        // Refresh failed, redirect to login\n        await AsyncStorage.multiRemove(['authToken', 'refreshToken']);\n        // Note: In a real app, you'd handle navigation here\n        console.log('Session expired, please log in again');\n      }\n    }\n\n    return Promise.reject(error);\n  }\n);\n\n// Add type-safe request methods\nconst typedApiService = {\n  get: <T = any>(url: string, config?: AxiosRequestConfig): Promise<AxiosResponse<T>> => \n    apiService.get<T>(url, config),\n  \n  post: <T = any>(\n    url: string, \n    data?: any, \n    config?: AxiosRequestConfig\n  ): Promise<AxiosResponse<T>> => \n    apiService.post<T>(url, data, config),\n  \n  put: <T = any>(\n    url: string, \n    data?: any, \n    config?: AxiosRequestConfig\n  ): Promise<AxiosResponse<T>> => \n    apiService.put<T>(url, data, config),\n  \n  delete: <T = any>(url: string, config?: AxiosRequestConfig): Promise<AxiosResponse<T>> => \n    apiService.delete<T>(url, config),\n  \n  patch: <T = any>(\n    url: string, \n    data?: any, \n    config?: AxiosRequestConfig\n  ): Promise<AxiosResponse<T>> => \n    apiService.patch<T>(url, data, config),\n};\n\nexport default typedApiService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}