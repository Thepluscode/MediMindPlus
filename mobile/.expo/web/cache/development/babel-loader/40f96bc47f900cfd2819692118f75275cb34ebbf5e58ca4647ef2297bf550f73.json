{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { Accelerometer, Gyroscope, Magnetometer } from 'expo-sensors';\nimport * as Location from 'expo-location';\nimport { Audio } from 'expo-av';\nimport { store } from \"../store/store\";\nimport { updateActivityData } from \"../store/slices/healthDataSlice\";\nvar SensorService = function () {\n  function SensorService() {\n    _classCallCheck(this, SensorService);\n    this.isMonitoring = false;\n    this.sensors = {\n      accelerometer: null,\n      gyroscope: null,\n      magnetometer: null,\n      location: null\n    };\n    this.sensorData = {\n      accelerometer: [],\n      gyroscope: [],\n      magnetometer: [],\n      location: []\n    };\n    this.recording = null;\n  }\n  return _createClass(SensorService, [{\n    key: \"initialize\",\n    value: function () {\n      var _initialize = _asyncToGenerator(function* () {\n        try {\n          var _yield$Audio$requestP = yield Audio.requestPermissionsAsync(),\n            audioStatus = _yield$Audio$requestP.status;\n          var _yield$Location$reque = yield Location.requestForegroundPermissionsAsync(),\n            locationStatus = _yield$Location$reque.status;\n          if (audioStatus !== 'granted' || locationStatus !== 'granted') {\n            console.warn('Required permissions not granted');\n            return false;\n          }\n          Accelerometer.setUpdateInterval(SensorService.UPDATE_INTERVAL_MS);\n          Gyroscope.setUpdateInterval(SensorService.UPDATE_INTERVAL_MS);\n          Magnetometer.setUpdateInterval(1000);\n          return true;\n        } catch (error) {\n          console.error('Sensor initialization failed:', error);\n          return false;\n        }\n      });\n      function initialize() {\n        return _initialize.apply(this, arguments);\n      }\n      return initialize;\n    }()\n  }, {\n    key: \"startMonitoring\",\n    value: function () {\n      var _startMonitoring = _asyncToGenerator(function* () {\n        var _this = this;\n        if (this.isMonitoring) return;\n        try {\n          this.isMonitoring = true;\n          this.sensors.accelerometer = Accelerometer.addListener(function (data) {\n            var dataPoint = _objectSpread(_objectSpread({}, data), {}, {\n              timestamp: Date.now()\n            });\n            _this.sensorData.accelerometer.push(dataPoint);\n            if (_this.sensorData.accelerometer.length > SensorService.SENSOR_DATA_LIMIT) {\n              _this.sensorData.accelerometer.shift();\n            }\n            if (_this.sensorData.accelerometer.length % 100 === 0) {\n              _this.processGaitData();\n            }\n          });\n          this.sensors.gyroscope = Gyroscope.addListener(function (data) {\n            _this.sensorData.gyroscope.push(_objectSpread(_objectSpread({}, data), {}, {\n              timestamp: Date.now()\n            }));\n            if (_this.sensorData.gyroscope.length > SensorService.SENSOR_DATA_LIMIT) {\n              _this.sensorData.gyroscope.shift();\n            }\n          });\n          this.sensors.magnetometer = Magnetometer.addListener(function (data) {\n            _this.sensorData.magnetometer.push(_objectSpread(_objectSpread({}, data), {}, {\n              timestamp: Date.now()\n            }));\n            if (_this.sensorData.magnetometer.length > SensorService.MAGNETOMETER_DATA_LIMIT) {\n              _this.sensorData.magnetometer.shift();\n            }\n          });\n          this.sensors.location = yield Location.watchPositionAsync({\n            accuracy: Location.Accuracy.Balanced,\n            timeInterval: 10000,\n            distanceInterval: 10\n          }, function (location) {\n            _this.sensorData.location.push(_objectSpread(_objectSpread({}, location), {}, {\n              timestamp: Date.now()\n            }));\n            if (_this.sensorData.location.length > 100) {\n              _this.sensorData.location.shift();\n            }\n          });\n        } catch (error) {\n          console.error('Failed to start sensor monitoring:', error);\n          this.stopMonitoring();\n          throw error;\n        }\n      });\n      function startMonitoring() {\n        return _startMonitoring.apply(this, arguments);\n      }\n      return startMonitoring;\n    }()\n  }, {\n    key: \"stopMonitoring\",\n    value: function stopMonitoring() {\n      if (!this.isMonitoring) return;\n      Object.values(this.sensors).forEach(function (sensor) {\n        if (sensor && 'remove' in sensor) {\n          sensor.remove();\n        }\n      });\n      this.sensors = {\n        accelerometer: null,\n        gyroscope: null,\n        magnetometer: null,\n        location: null\n      };\n      this.isMonitoring = false;\n    }\n  }, {\n    key: \"startRecording\",\n    value: function startRecording() {\n      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'custom';\n      if (this.recording) {\n        throw new Error('A recording is already in progress');\n      }\n      var recordingId = `rec_${Date.now()}`;\n      this.recording = {\n        id: recordingId,\n        startTime: Date.now(),\n        endTime: null,\n        type: type,\n        data: {}\n      };\n      return recordingId;\n    }\n  }, {\n    key: \"stopRecording\",\n    value: function stopRecording() {\n      if (!this.recording) return null;\n      var recording = _objectSpread(_objectSpread({}, this.recording), {}, {\n        endTime: Date.now(),\n        data: _objectSpread({}, this.sensorData)\n      });\n      this.recording = null;\n      return recording;\n    }\n  }, {\n    key: \"getSensorData\",\n    value: function getSensorData() {\n      return _objectSpread({}, this.sensorData);\n    }\n  }, {\n    key: \"clearSensorData\",\n    value: function clearSensorData() {\n      this.sensorData = {\n        accelerometer: [],\n        gyroscope: [],\n        magnetometer: [],\n        location: []\n      };\n    }\n  }, {\n    key: \"processGaitData\",\n    value: function processGaitData() {\n      var accelerometer = this.sensorData.accelerometer;\n      if (accelerometer.length < 10) return;\n      var lastReading = accelerometer[accelerometer.length - 1];\n      var prevReading = accelerometer[Math.max(0, accelerometer.length - 10)];\n      var deltaX = Math.abs(lastReading.x - prevReading.x);\n      var deltaY = Math.abs(lastReading.y - prevReading.y);\n      var deltaZ = Math.abs(lastReading.z - prevReading.z);\n      var totalAcceleration = Math.sqrt(deltaX ** 2 + deltaY ** 2 + deltaZ ** 2);\n      if (totalAcceleration > 1.5) {\n        store.dispatch(updateActivityData({\n          steps: 1,\n          timestamp: new Date().toISOString()\n        }));\n      }\n    }\n  }, {\n    key: \"getCurrentLocation\",\n    value: function () {\n      var _getCurrentLocation = _asyncToGenerator(function* () {\n        try {\n          var location = yield Location.getCurrentPositionAsync({\n            accuracy: Location.Accuracy.High\n          });\n          return location;\n        } catch (error) {\n          console.error('Error getting current location:', error);\n          return null;\n        }\n      });\n      function getCurrentLocation() {\n        return _getCurrentLocation.apply(this, arguments);\n      }\n      return getCurrentLocation;\n    }()\n  }]);\n}();\nSensorService.SENSOR_DATA_LIMIT = 1000;\nSensorService.MAGNETOMETER_DATA_LIMIT = 100;\nSensorService.UPDATE_INTERVAL_MS = 100;\nexport var sensorService = new SensorService();","map":{"version":3,"names":["Accelerometer","Gyroscope","Magnetometer","Location","Audio","store","updateActivityData","SensorService","_classCallCheck","isMonitoring","sensors","accelerometer","gyroscope","magnetometer","location","sensorData","recording","_createClass","key","value","_initialize","_asyncToGenerator","_yield$Audio$requestP","requestPermissionsAsync","audioStatus","status","_yield$Location$reque","requestForegroundPermissionsAsync","locationStatus","console","warn","setUpdateInterval","UPDATE_INTERVAL_MS","error","initialize","apply","arguments","_startMonitoring","_this","addListener","data","dataPoint","_objectSpread","timestamp","Date","now","push","length","SENSOR_DATA_LIMIT","shift","processGaitData","MAGNETOMETER_DATA_LIMIT","watchPositionAsync","accuracy","Accuracy","Balanced","timeInterval","distanceInterval","stopMonitoring","startMonitoring","Object","values","forEach","sensor","remove","startRecording","type","undefined","Error","recordingId","id","startTime","endTime","stopRecording","getSensorData","clearSensorData","lastReading","prevReading","Math","max","deltaX","abs","x","deltaY","y","deltaZ","z","totalAcceleration","sqrt","dispatch","steps","toISOString","_getCurrentLocation","getCurrentPositionAsync","High","getCurrentLocation","sensorService"],"sources":["/Users/theophilusogieva/Desktop/MediMindPlus/MediMindPlus/frontend/src/services/sensorService.ts"],"sourcesContent":["import { Accelerometer, Gyroscope, Magnetometer, AccelerometerMeasurement, GyroscopeMeasurement, MagnetometerMeasurement } from 'expo-sensors';\nimport * as Location from 'expo-location';\nimport * as Permissions from 'expo-permissions';\nimport { Audio } from 'expo-av';\nimport { Subscription } from 'expo-modules-core';\nimport { store } from '../store/store';\nimport { addHeartRateData, updateActivityData, updateVoiceData } from '../store/slices/healthDataSlice';\n\ninterface SensorDataPoint<T> {\n  x: number;\n  y: number;\n  z: number;\n  timestamp: number;\n}\n\ntype SensorType = 'accelerometer' | 'gyroscope' | 'magnetometer' | 'location';\n\ninterface SensorData {\n  accelerometer: SensorDataPoint<AccelerometerMeasurement>[];\n  gyroscope: SensorDataPoint<GyroscopeMeasurement>[];\n  magnetometer: SensorDataPoint<MagnetometerMeasurement>[];\n  location: Array<Location.LocationObject & { timestamp: number }>;\n}\n\ninterface SensorSubscriptions {\n  accelerometer: Subscription | null;\n  gyroscope: Subscription | null;\n  magnetometer: Subscription | null;\n  location: Subscription | null;\n}\n\ninterface Recording {\n  id: string;\n  startTime: number;\n  endTime: number | null;\n  type: 'walking' | 'running' | 'standing' | 'custom';\n  data: {\n    [key in SensorType]?: any[];\n  };\n}\n\nclass SensorService {\n  private isMonitoring: boolean = false;\n  private sensors: SensorSubscriptions = {\n    accelerometer: null,\n    gyroscope: null,\n    magnetometer: null,\n    location: null,\n  };\n  private sensorData: SensorData = {\n    accelerometer: [],\n    gyroscope: [],\n    magnetometer: [],\n    location: [],\n  };\n  private recording: Recording | null = null;\n  private static readonly SENSOR_DATA_LIMIT = 1000;\n  private static readonly MAGNETOMETER_DATA_LIMIT = 100;\n  private static readonly UPDATE_INTERVAL_MS = 100; // 10Hz\n\n  async initialize(): Promise<boolean> {\n    try {\n      // Request permissions\n      const { status: audioStatus } = await Audio.requestPermissionsAsync();\n      const { status: locationStatus } = await Location.requestForegroundPermissionsAsync();\n      \n      if (audioStatus !== 'granted' || locationStatus !== 'granted') {\n        console.warn('Required permissions not granted');\n        return false;\n      }\n\n      // Set sensor update intervals\n      Accelerometer.setUpdateInterval(SensorService.UPDATE_INTERVAL_MS);\n      Gyroscope.setUpdateInterval(SensorService.UPDATE_INTERVAL_MS);\n      Magnetometer.setUpdateInterval(1000); // 1Hz\n\n      return true;\n    } catch (error) {\n      console.error('Sensor initialization failed:', error);\n      return false;\n    }\n  }\n\n  async startMonitoring(): Promise<void> {\n    if (this.isMonitoring) return;\n\n    try {\n      this.isMonitoring = true;\n\n      // Start accelerometer monitoring\n      this.sensors.accelerometer = Accelerometer.addListener(\n        (data: AccelerometerMeasurement) => {\n          const dataPoint: SensorDataPoint<AccelerometerMeasurement> = {\n            ...data,\n            timestamp: Date.now(),\n          };\n          \n          this.sensorData.accelerometer.push(dataPoint);\n          \n          // Keep only last SENSOR_DATA_LIMIT readings\n          if (this.sensorData.accelerometer.length > SensorService.SENSOR_DATA_LIMIT) {\n            this.sensorData.accelerometer.shift();\n          }\n\n          // Process gait data every 100 readings\n          if (this.sensorData.accelerometer.length % 100 === 0) {\n            this.processGaitData();\n          }\n        }\n      );\n\n      // Start gyroscope monitoring\n      this.sensors.gyroscope = Gyroscope.addListener(\n        (data: GyroscopeMeasurement) => {\n          this.sensorData.gyroscope.push({\n            ...data,\n            timestamp: Date.now(),\n          });\n          \n          if (this.sensorData.gyroscope.length > SensorService.SENSOR_DATA_LIMIT) {\n            this.sensorData.gyroscope.shift();\n          }\n        }\n      );\n\n      // Start magnetometer monitoring\n      this.sensors.magnetometer = Magnetometer.addListener(\n        (data: MagnetometerMeasurement) => {\n          this.sensorData.magnetometer.push({\n            ...data,\n            timestamp: Date.now(),\n          });\n          \n          if (this.sensorData.magnetometer.length > SensorService.MAGNETOMETER_DATA_LIMIT) {\n            this.sensorData.magnetometer.shift();\n          }\n        }\n      );\n\n      // Start location monitoring\n      this.sensors.location = await Location.watchPositionAsync(\n        {\n          accuracy: Location.Accuracy.Balanced,\n          timeInterval: 10000, // 10 seconds\n          distanceInterval: 10, // 10 meters\n        },\n        (location: Location.LocationObject) => {\n          this.sensorData.location.push({\n            ...location,\n            timestamp: Date.now(),\n          });\n          \n          if (this.sensorData.location.length > 100) {\n            this.sensorData.location.shift();\n          }\n        }\n      );\n\n    } catch (error) {\n      console.error('Failed to start sensor monitoring:', error);\n      this.stopMonitoring();\n      throw error;\n    }\n  }\n\n  stopMonitoring(): void {\n    if (!this.isMonitoring) return;\n\n    // Remove all listeners\n    Object.values(this.sensors).forEach(sensor => {\n      if (sensor && 'remove' in sensor) {\n        sensor.remove();\n      }\n    });\n\n    // Reset state\n    this.sensors = {\n      accelerometer: null,\n      gyroscope: null,\n      magnetometer: null,\n      location: null,\n    };\n    \n    this.isMonitoring = false;\n  }\n\n  startRecording(type: Recording['type'] = 'custom'): string {\n    if (this.recording) {\n      throw new Error('A recording is already in progress');\n    }\n\n    const recordingId = `rec_${Date.now()}`;\n    this.recording = {\n      id: recordingId,\n      startTime: Date.now(),\n      endTime: null,\n      type,\n      data: {},\n    };\n\n    return recordingId;\n  }\n\n  stopRecording(): Recording | null {\n    if (!this.recording) return null;\n\n    const recording = {\n      ...this.recording,\n      endTime: Date.now(),\n      data: { ...this.sensorData },\n    };\n\n    this.recording = null;\n    return recording;\n  }\n\n  getSensorData(): SensorData {\n    return { ...this.sensorData };\n  }\n\n  clearSensorData(): void {\n    this.sensorData = {\n      accelerometer: [],\n      gyroscope: [],\n      magnetometer: [],\n      location: [],\n    };\n  }\n\n  private processGaitData(): void {\n    const { accelerometer } = this.sensorData;\n    if (accelerometer.length < 10) return;\n\n    // Simple step detection based on accelerometer data\n    const lastReading = accelerometer[accelerometer.length - 1];\n    const prevReading = accelerometer[Math.max(0, accelerometer.length - 10)];\n    \n    const deltaX = Math.abs(lastReading.x - prevReading.x);\n    const deltaY = Math.abs(lastReading.y - prevReading.y);\n    const deltaZ = Math.abs(lastReading.z - prevReading.z);\n    \n    const totalAcceleration = Math.sqrt(deltaX ** 2 + deltaY ** 2 + deltaZ ** 2);\n    \n    // Threshold for step detection (adjust based on testing)\n    if (totalAcceleration > 1.5) {\n      // Dispatch step count update to Redux store\n      store.dispatch(updateActivityData({\n        steps: 1, // Increment step count\n        timestamp: new Date().toISOString(),\n      }));\n    }\n  }\n\n  // Add any additional sensor processing methods here\n  async getCurrentLocation(): Promise<Location.LocationObject | null> {\n    try {\n      const location = await Location.getCurrentPositionAsync({\n        accuracy: Location.Accuracy.High,\n      });\n      return location;\n    } catch (error) {\n      console.error('Error getting current location:', error);\n      return null;\n    }\n  }\n}\n\nexport const sensorService = new SensorService();\n\nexport type { SensorData, SensorDataPoint, Recording };\n"],"mappings":";;;;;;AAAA,SAASA,aAAa,EAAEC,SAAS,EAAEC,YAAY,QAAiF,cAAc;AAC9I,OAAO,KAAKC,QAAQ,MAAM,eAAe;AAEzC,SAASC,KAAK,QAAQ,SAAS;AAE/B,SAASC,KAAK;AACd,SAA2BC,kBAAkB;AAA2D,IAmClGC,aAAa;EAAA,SAAAA,cAAA;IAAAC,eAAA,OAAAD,aAAA;IAAA,KACTE,YAAY,GAAY,KAAK;IAAA,KAC7BC,OAAO,GAAwB;MACrCC,aAAa,EAAE,IAAI;MACnBC,SAAS,EAAE,IAAI;MACfC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE;IACZ,CAAC;IAAA,KACOC,UAAU,GAAe;MAC/BJ,aAAa,EAAE,EAAE;MACjBC,SAAS,EAAE,EAAE;MACbC,YAAY,EAAE,EAAE;MAChBC,QAAQ,EAAE;IACZ,CAAC;IAAA,KACOE,SAAS,GAAqB,IAAI;EAAA;EAAA,OAAAC,YAAA,CAAAV,aAAA;IAAAW,GAAA;IAAAC,KAAA;MAAA,IAAAC,WAAA,GAAAC,iBAAA,CAK1C,aAAqC;QACnC,IAAI;UAEF,IAAAC,qBAAA,SAAsClB,KAAK,CAACmB,uBAAuB,CAAC,CAAC;YAArDC,WAAW,GAAAF,qBAAA,CAAnBG,MAAM;UACd,IAAAC,qBAAA,SAAyCvB,QAAQ,CAACwB,iCAAiC,CAAC,CAAC;YAArEC,cAAc,GAAAF,qBAAA,CAAtBD,MAAM;UAEd,IAAID,WAAW,KAAK,SAAS,IAAII,cAAc,KAAK,SAAS,EAAE;YAC7DC,OAAO,CAACC,IAAI,CAAC,kCAAkC,CAAC;YAChD,OAAO,KAAK;UACd;UAGA9B,aAAa,CAAC+B,iBAAiB,CAACxB,aAAa,CAACyB,kBAAkB,CAAC;UACjE/B,SAAS,CAAC8B,iBAAiB,CAACxB,aAAa,CAACyB,kBAAkB,CAAC;UAC7D9B,YAAY,CAAC6B,iBAAiB,CAAC,IAAI,CAAC;UAEpC,OAAO,IAAI;QACb,CAAC,CAAC,OAAOE,KAAK,EAAE;UACdJ,OAAO,CAACI,KAAK,CAAC,+BAA+B,EAAEA,KAAK,CAAC;UACrD,OAAO,KAAK;QACd;MACF,CAAC;MAAA,SArBKC,UAAUA,CAAA;QAAA,OAAAd,WAAA,CAAAe,KAAA,OAAAC,SAAA;MAAA;MAAA,OAAVF,UAAU;IAAA;EAAA;IAAAhB,GAAA;IAAAC,KAAA;MAAA,IAAAkB,gBAAA,GAAAhB,iBAAA,CAuBhB,aAAuC;QAAA,IAAAiB,KAAA;QACrC,IAAI,IAAI,CAAC7B,YAAY,EAAE;QAEvB,IAAI;UACF,IAAI,CAACA,YAAY,GAAG,IAAI;UAGxB,IAAI,CAACC,OAAO,CAACC,aAAa,GAAGX,aAAa,CAACuC,WAAW,CACpD,UAACC,IAA8B,EAAK;YAClC,IAAMC,SAAoD,GAAAC,aAAA,CAAAA,aAAA,KACrDF,IAAI;cACPG,SAAS,EAAEC,IAAI,CAACC,GAAG,CAAC;YAAC,EACtB;YAEDP,KAAI,CAACvB,UAAU,CAACJ,aAAa,CAACmC,IAAI,CAACL,SAAS,CAAC;YAG7C,IAAIH,KAAI,CAACvB,UAAU,CAACJ,aAAa,CAACoC,MAAM,GAAGxC,aAAa,CAACyC,iBAAiB,EAAE;cAC1EV,KAAI,CAACvB,UAAU,CAACJ,aAAa,CAACsC,KAAK,CAAC,CAAC;YACvC;YAGA,IAAIX,KAAI,CAACvB,UAAU,CAACJ,aAAa,CAACoC,MAAM,GAAG,GAAG,KAAK,CAAC,EAAE;cACpDT,KAAI,CAACY,eAAe,CAAC,CAAC;YACxB;UACF,CACF,CAAC;UAGD,IAAI,CAACxC,OAAO,CAACE,SAAS,GAAGX,SAAS,CAACsC,WAAW,CAC5C,UAACC,IAA0B,EAAK;YAC9BF,KAAI,CAACvB,UAAU,CAACH,SAAS,CAACkC,IAAI,CAAAJ,aAAA,CAAAA,aAAA,KACzBF,IAAI;cACPG,SAAS,EAAEC,IAAI,CAACC,GAAG,CAAC;YAAC,EACtB,CAAC;YAEF,IAAIP,KAAI,CAACvB,UAAU,CAACH,SAAS,CAACmC,MAAM,GAAGxC,aAAa,CAACyC,iBAAiB,EAAE;cACtEV,KAAI,CAACvB,UAAU,CAACH,SAAS,CAACqC,KAAK,CAAC,CAAC;YACnC;UACF,CACF,CAAC;UAGD,IAAI,CAACvC,OAAO,CAACG,YAAY,GAAGX,YAAY,CAACqC,WAAW,CAClD,UAACC,IAA6B,EAAK;YACjCF,KAAI,CAACvB,UAAU,CAACF,YAAY,CAACiC,IAAI,CAAAJ,aAAA,CAAAA,aAAA,KAC5BF,IAAI;cACPG,SAAS,EAAEC,IAAI,CAACC,GAAG,CAAC;YAAC,EACtB,CAAC;YAEF,IAAIP,KAAI,CAACvB,UAAU,CAACF,YAAY,CAACkC,MAAM,GAAGxC,aAAa,CAAC4C,uBAAuB,EAAE;cAC/Eb,KAAI,CAACvB,UAAU,CAACF,YAAY,CAACoC,KAAK,CAAC,CAAC;YACtC;UACF,CACF,CAAC;UAGD,IAAI,CAACvC,OAAO,CAACI,QAAQ,SAASX,QAAQ,CAACiD,kBAAkB,CACvD;YACEC,QAAQ,EAAElD,QAAQ,CAACmD,QAAQ,CAACC,QAAQ;YACpCC,YAAY,EAAE,KAAK;YACnBC,gBAAgB,EAAE;UACpB,CAAC,EACD,UAAC3C,QAAiC,EAAK;YACrCwB,KAAI,CAACvB,UAAU,CAACD,QAAQ,CAACgC,IAAI,CAAAJ,aAAA,CAAAA,aAAA,KACxB5B,QAAQ;cACX6B,SAAS,EAAEC,IAAI,CAACC,GAAG,CAAC;YAAC,EACtB,CAAC;YAEF,IAAIP,KAAI,CAACvB,UAAU,CAACD,QAAQ,CAACiC,MAAM,GAAG,GAAG,EAAE;cACzCT,KAAI,CAACvB,UAAU,CAACD,QAAQ,CAACmC,KAAK,CAAC,CAAC;YAClC;UACF,CACF,CAAC;QAEH,CAAC,CAAC,OAAOhB,KAAK,EAAE;UACdJ,OAAO,CAACI,KAAK,CAAC,oCAAoC,EAAEA,KAAK,CAAC;UAC1D,IAAI,CAACyB,cAAc,CAAC,CAAC;UACrB,MAAMzB,KAAK;QACb;MACF,CAAC;MAAA,SAhFK0B,eAAeA,CAAA;QAAA,OAAAtB,gBAAA,CAAAF,KAAA,OAAAC,SAAA;MAAA;MAAA,OAAfuB,eAAe;IAAA;EAAA;IAAAzC,GAAA;IAAAC,KAAA,EAkFrB,SAAAuC,cAAcA,CAAA,EAAS;MACrB,IAAI,CAAC,IAAI,CAACjD,YAAY,EAAE;MAGxBmD,MAAM,CAACC,MAAM,CAAC,IAAI,CAACnD,OAAO,CAAC,CAACoD,OAAO,CAAC,UAAAC,MAAM,EAAI;QAC5C,IAAIA,MAAM,IAAI,QAAQ,IAAIA,MAAM,EAAE;UAChCA,MAAM,CAACC,MAAM,CAAC,CAAC;QACjB;MACF,CAAC,CAAC;MAGF,IAAI,CAACtD,OAAO,GAAG;QACbC,aAAa,EAAE,IAAI;QACnBC,SAAS,EAAE,IAAI;QACfC,YAAY,EAAE,IAAI;QAClBC,QAAQ,EAAE;MACZ,CAAC;MAED,IAAI,CAACL,YAAY,GAAG,KAAK;IAC3B;EAAC;IAAAS,GAAA;IAAAC,KAAA,EAED,SAAA8C,cAAcA,CAAA,EAA6C;MAAA,IAA5CC,IAAuB,GAAA9B,SAAA,CAAAW,MAAA,QAAAX,SAAA,QAAA+B,SAAA,GAAA/B,SAAA,MAAG,QAAQ;MAC/C,IAAI,IAAI,CAACpB,SAAS,EAAE;QAClB,MAAM,IAAIoD,KAAK,CAAC,oCAAoC,CAAC;MACvD;MAEA,IAAMC,WAAW,GAAG,OAAOzB,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE;MACvC,IAAI,CAAC7B,SAAS,GAAG;QACfsD,EAAE,EAAED,WAAW;QACfE,SAAS,EAAE3B,IAAI,CAACC,GAAG,CAAC,CAAC;QACrB2B,OAAO,EAAE,IAAI;QACbN,IAAI,EAAJA,IAAI;QACJ1B,IAAI,EAAE,CAAC;MACT,CAAC;MAED,OAAO6B,WAAW;IACpB;EAAC;IAAAnD,GAAA;IAAAC,KAAA,EAED,SAAAsD,aAAaA,CAAA,EAAqB;MAChC,IAAI,CAAC,IAAI,CAACzD,SAAS,EAAE,OAAO,IAAI;MAEhC,IAAMA,SAAS,GAAA0B,aAAA,CAAAA,aAAA,KACV,IAAI,CAAC1B,SAAS;QACjBwD,OAAO,EAAE5B,IAAI,CAACC,GAAG,CAAC,CAAC;QACnBL,IAAI,EAAAE,aAAA,KAAO,IAAI,CAAC3B,UAAU;MAAE,EAC7B;MAED,IAAI,CAACC,SAAS,GAAG,IAAI;MACrB,OAAOA,SAAS;IAClB;EAAC;IAAAE,GAAA;IAAAC,KAAA,EAED,SAAAuD,aAAaA,CAAA,EAAe;MAC1B,OAAAhC,aAAA,KAAY,IAAI,CAAC3B,UAAU;IAC7B;EAAC;IAAAG,GAAA;IAAAC,KAAA,EAED,SAAAwD,eAAeA,CAAA,EAAS;MACtB,IAAI,CAAC5D,UAAU,GAAG;QAChBJ,aAAa,EAAE,EAAE;QACjBC,SAAS,EAAE,EAAE;QACbC,YAAY,EAAE,EAAE;QAChBC,QAAQ,EAAE;MACZ,CAAC;IACH;EAAC;IAAAI,GAAA;IAAAC,KAAA,EAED,SAAQ+B,eAAeA,CAAA,EAAS;MAC9B,IAAQvC,aAAa,GAAK,IAAI,CAACI,UAAU,CAAjCJ,aAAa;MACrB,IAAIA,aAAa,CAACoC,MAAM,GAAG,EAAE,EAAE;MAG/B,IAAM6B,WAAW,GAAGjE,aAAa,CAACA,aAAa,CAACoC,MAAM,GAAG,CAAC,CAAC;MAC3D,IAAM8B,WAAW,GAAGlE,aAAa,CAACmE,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEpE,aAAa,CAACoC,MAAM,GAAG,EAAE,CAAC,CAAC;MAEzE,IAAMiC,MAAM,GAAGF,IAAI,CAACG,GAAG,CAACL,WAAW,CAACM,CAAC,GAAGL,WAAW,CAACK,CAAC,CAAC;MACtD,IAAMC,MAAM,GAAGL,IAAI,CAACG,GAAG,CAACL,WAAW,CAACQ,CAAC,GAAGP,WAAW,CAACO,CAAC,CAAC;MACtD,IAAMC,MAAM,GAAGP,IAAI,CAACG,GAAG,CAACL,WAAW,CAACU,CAAC,GAAGT,WAAW,CAACS,CAAC,CAAC;MAEtD,IAAMC,iBAAiB,GAAGT,IAAI,CAACU,IAAI,CAACR,MAAM,IAAI,CAAC,GAAGG,MAAM,IAAI,CAAC,GAAGE,MAAM,IAAI,CAAC,CAAC;MAG5E,IAAIE,iBAAiB,GAAG,GAAG,EAAE;QAE3BlF,KAAK,CAACoF,QAAQ,CAACnF,kBAAkB,CAAC;UAChCoF,KAAK,EAAE,CAAC;UACR/C,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAAC+C,WAAW,CAAC;QACpC,CAAC,CAAC,CAAC;MACL;IACF;EAAC;IAAAzE,GAAA;IAAAC,KAAA;MAAA,IAAAyE,mBAAA,GAAAvE,iBAAA,CAGD,aAAoE;QAClE,IAAI;UACF,IAAMP,QAAQ,SAASX,QAAQ,CAAC0F,uBAAuB,CAAC;YACtDxC,QAAQ,EAAElD,QAAQ,CAACmD,QAAQ,CAACwC;UAC9B,CAAC,CAAC;UACF,OAAOhF,QAAQ;QACjB,CAAC,CAAC,OAAOmB,KAAK,EAAE;UACdJ,OAAO,CAACI,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;UACvD,OAAO,IAAI;QACb;MACF,CAAC;MAAA,SAVK8D,kBAAkBA,CAAA;QAAA,OAAAH,mBAAA,CAAAzD,KAAA,OAAAC,SAAA;MAAA;MAAA,OAAlB2D,kBAAkB;IAAA;EAAA;AAAA;AArNpBxF,aAAa,CAeOyC,iBAAiB,GAAG,IAAI;AAf5CzC,aAAa,CAgBO4C,uBAAuB,GAAG,GAAG;AAhBjD5C,aAAa,CAiBOyB,kBAAkB,GAAG,GAAG;AAiNlD,OAAO,IAAMgE,aAAa,GAAG,IAAIzF,aAAa,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}