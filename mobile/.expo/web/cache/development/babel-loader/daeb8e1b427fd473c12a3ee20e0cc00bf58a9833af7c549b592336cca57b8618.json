{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar CryptographicEngine = function () {\n  function CryptographicEngine() {\n    _classCallCheck(this, CryptographicEngine);\n    this.keyPairs = new Map();\n  }\n  return _createClass(CryptographicEngine, [{\n    key: \"generateKeyPair\",\n    value: function () {\n      var _generateKeyPair = _asyncToGenerator(function* (userId) {\n        var keyPair = {\n          publicKey: `pub_${userId}_${Date.now()}`,\n          privateKey: `priv_${userId}_${Date.now()}`\n        };\n        this.keyPairs.set(userId, keyPair);\n        console.log(`üîë Generated key pair for user: ${userId}`);\n        return keyPair;\n      });\n      function generateKeyPair(_x) {\n        return _generateKeyPair.apply(this, arguments);\n      }\n      return generateKeyPair;\n    }()\n  }, {\n    key: \"signData\",\n    value: function () {\n      var _signData = _asyncToGenerator(function* (data, privateKey) {\n        var dataString = JSON.stringify(data);\n        var signature = btoa(`${privateKey}_${dataString}_${Date.now()}`);\n        return signature;\n      });\n      function signData(_x2, _x3) {\n        return _signData.apply(this, arguments);\n      }\n      return signData;\n    }()\n  }, {\n    key: \"verifySignature\",\n    value: function () {\n      var _verifySignature = _asyncToGenerator(function* (data, signature, publicKey) {\n        var dataString = JSON.stringify(data);\n        var decodedSig = atob(signature);\n        return decodedSig.includes(publicKey.replace('pub_', 'priv_'));\n      });\n      function verifySignature(_x4, _x5, _x6) {\n        return _verifySignature.apply(this, arguments);\n      }\n      return verifySignature;\n    }()\n  }, {\n    key: \"hashData\",\n    value: function () {\n      var _hashData = _asyncToGenerator(function* (data) {\n        var dataString = JSON.stringify(data);\n        var hash = 0;\n        for (var i = 0; i < dataString.length; i++) {\n          var char = dataString.charCodeAt(i);\n          hash = (hash << 5) - hash + char;\n          hash = hash & hash;\n        }\n        return Math.abs(hash).toString(16);\n      });\n      function hashData(_x7) {\n        return _hashData.apply(this, arguments);\n      }\n      return hashData;\n    }()\n  }, {\n    key: \"encryptData\",\n    value: function () {\n      var _encryptData = _asyncToGenerator(function* (data, publicKey) {\n        var dataString = JSON.stringify(data);\n        return btoa(`${publicKey}_${dataString}`);\n      });\n      function encryptData(_x8, _x9) {\n        return _encryptData.apply(this, arguments);\n      }\n      return encryptData;\n    }()\n  }, {\n    key: \"decryptData\",\n    value: function () {\n      var _decryptData = _asyncToGenerator(function* (encryptedData, privateKey) {\n        var decoded = atob(encryptedData);\n        var parts = decoded.split('_');\n        if (parts.length >= 2) {\n          var dataString = parts.slice(1).join('_');\n          return JSON.parse(dataString);\n        }\n        throw new Error('Decryption failed');\n      });\n      function decryptData(_x0, _x1) {\n        return _decryptData.apply(this, arguments);\n      }\n      return decryptData;\n    }()\n  }]);\n}();\nvar SmartContractEngine = function () {\n  function SmartContractEngine() {\n    _classCallCheck(this, SmartContractEngine);\n    this.contracts = new Map();\n    this.contractExecutions = new Map();\n  }\n  return _createClass(SmartContractEngine, [{\n    key: \"deployContract\",\n    value: function () {\n      var _deployContract = _asyncToGenerator(function* (contract) {\n        var contractId = `contract_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n        var deployedContract = _objectSpread(_objectSpread({}, contract), {}, {\n          id: contractId,\n          deployedAt: new Date()\n        });\n        this.contracts.set(contractId, deployedContract);\n        console.log(`üìú Smart contract deployed: ${contractId} (${contract.type})`);\n        return contractId;\n      });\n      function deployContract(_x10) {\n        return _deployContract.apply(this, arguments);\n      }\n      return deployContract;\n    }()\n  }, {\n    key: \"executeContract\",\n    value: function () {\n      var _executeContract = _asyncToGenerator(function* (contractId, params) {\n        var contract = this.contracts.get(contractId);\n        if (!contract || !contract.isActive) {\n          throw new Error('Contract not found or inactive');\n        }\n        var execution = {\n          contractId: contractId,\n          params: params,\n          timestamp: new Date(),\n          result: this.simulateContractExecution(contract, params)\n        };\n        var executions = this.contractExecutions.get(contractId) || [];\n        executions.push(execution);\n        this.contractExecutions.set(contractId, executions);\n        console.log(`‚ö° Contract executed: ${contractId}`);\n        return execution.result;\n      });\n      function executeContract(_x11, _x12) {\n        return _executeContract.apply(this, arguments);\n      }\n      return executeContract;\n    }()\n  }, {\n    key: \"simulateContractExecution\",\n    value: function simulateContractExecution(contract, params) {\n      switch (contract.type) {\n        case 'consent':\n          return this.executeConsentContract(params);\n        case 'access_control':\n          return this.executeAccessControlContract(params);\n        case 'data_sharing':\n          return this.executeDataSharingContract(params);\n        case 'audit':\n          return this.executeAuditContract(params);\n        default:\n          return {\n            success: false,\n            error: 'Unknown contract type'\n          };\n      }\n    }\n  }, {\n    key: \"executeConsentContract\",\n    value: function executeConsentContract(params) {\n      if (params.action === 'grant') {\n        return {\n          success: true,\n          consentId: `consent_${Date.now()}`,\n          grantedAt: new Date(),\n          expiresAt: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000)\n        };\n      } else if (params.action === 'revoke') {\n        return {\n          success: true,\n          revokedAt: new Date(),\n          reason: params.reason || 'Patient request'\n        };\n      }\n      return {\n        success: false,\n        error: 'Invalid consent action'\n      };\n    }\n  }, {\n    key: \"executeAccessControlContract\",\n    value: function executeAccessControlContract(params) {\n      var hasPermission = Math.random() > 0.1;\n      return {\n        success: hasPermission,\n        accessGranted: hasPermission,\n        reason: hasPermission ? 'Access granted' : 'Insufficient permissions',\n        timestamp: new Date()\n      };\n    }\n  }, {\n    key: \"executeDataSharingContract\",\n    value: function executeDataSharingContract(params) {\n      return {\n        success: true,\n        sharingId: `share_${Date.now()}`,\n        sharedWith: params.recipient,\n        dataTypes: params.dataTypes,\n        purpose: params.purpose,\n        expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)\n      };\n    }\n  }, {\n    key: \"executeAuditContract\",\n    value: function executeAuditContract(params) {\n      return {\n        success: true,\n        auditId: `audit_${Date.now()}`,\n        action: params.action,\n        timestamp: new Date(),\n        logged: true\n      };\n    }\n  }, {\n    key: \"getContract\",\n    value: function getContract(contractId) {\n      return this.contracts.get(contractId);\n    }\n  }, {\n    key: \"getContractExecutions\",\n    value: function getContractExecutions(contractId) {\n      return this.contractExecutions.get(contractId) || [];\n    }\n  }]);\n}();\nexport var HealthDataBlockchainService = function () {\n  function HealthDataBlockchainService() {\n    _classCallCheck(this, HealthDataBlockchainService);\n    this.isInitialized = false;\n    this.cryptoEngine = new CryptographicEngine();\n    this.contractEngine = new SmartContractEngine();\n    this.healthRecords = new Map();\n    this.consentRecords = new Map();\n    this.auditLogs = [];\n    this.blockchain = [];\n  }\n  return _createClass(HealthDataBlockchainService, [{\n    key: \"initialize\",\n    value: function () {\n      var _initialize = _asyncToGenerator(function* () {\n        try {\n          console.log('üîó Initializing Blockchain Health Data Management...');\n          yield this.deployConsentContract();\n          yield this.deployAccessControlContract();\n          yield this.deployDataSharingContract();\n          yield this.deployAuditContract();\n          yield this.createGenesisBlock();\n          this.isInitialized = true;\n          console.log('‚úÖ Blockchain Health Data Management initialized successfully');\n        } catch (error) {\n          console.error('‚ùå Failed to initialize Blockchain Health Data Management:', error);\n          throw error;\n        }\n      });\n      function initialize() {\n        return _initialize.apply(this, arguments);\n      }\n      return initialize;\n    }()\n  }, {\n    key: \"deployConsentContract\",\n    value: function () {\n      var _deployConsentContract = _asyncToGenerator(function* () {\n        yield this.contractEngine.deployContract({\n          type: 'consent',\n          code: 'consent_management_v1',\n          owner: 'system',\n          isActive: true\n        });\n      });\n      function deployConsentContract() {\n        return _deployConsentContract.apply(this, arguments);\n      }\n      return deployConsentContract;\n    }()\n  }, {\n    key: \"deployAccessControlContract\",\n    value: function () {\n      var _deployAccessControlContract = _asyncToGenerator(function* () {\n        yield this.contractEngine.deployContract({\n          type: 'access_control',\n          code: 'access_control_v1',\n          owner: 'system',\n          isActive: true\n        });\n      });\n      function deployAccessControlContract() {\n        return _deployAccessControlContract.apply(this, arguments);\n      }\n      return deployAccessControlContract;\n    }()\n  }, {\n    key: \"deployDataSharingContract\",\n    value: function () {\n      var _deployDataSharingContract = _asyncToGenerator(function* () {\n        yield this.contractEngine.deployContract({\n          type: 'data_sharing',\n          code: 'data_sharing_v1',\n          owner: 'system',\n          isActive: true\n        });\n      });\n      function deployDataSharingContract() {\n        return _deployDataSharingContract.apply(this, arguments);\n      }\n      return deployDataSharingContract;\n    }()\n  }, {\n    key: \"deployAuditContract\",\n    value: function () {\n      var _deployAuditContract = _asyncToGenerator(function* () {\n        yield this.contractEngine.deployContract({\n          type: 'audit',\n          code: 'audit_logging_v1',\n          owner: 'system',\n          isActive: true\n        });\n      });\n      function deployAuditContract() {\n        return _deployAuditContract.apply(this, arguments);\n      }\n      return deployAuditContract;\n    }()\n  }, {\n    key: \"createGenesisBlock\",\n    value: function () {\n      var _createGenesisBlock = _asyncToGenerator(function* () {\n        var genesisRecord = {\n          id: 'genesis',\n          patientId: 'system',\n          providerId: 'system',\n          recordType: 'vital_signs',\n          data: {\n            message: 'MediMind Blockchain Genesis Block'\n          },\n          timestamp: new Date(),\n          hash: yield this.cryptoEngine.hashData('genesis'),\n          previousHash: '0',\n          signature: 'genesis_signature',\n          accessPermissions: []\n        };\n        this.blockchain.push(genesisRecord);\n        console.log('üéØ Genesis block created');\n      });\n      function createGenesisBlock() {\n        return _createGenesisBlock.apply(this, arguments);\n      }\n      return createGenesisBlock;\n    }()\n  }, {\n    key: \"createHealthRecord\",\n    value: (function () {\n      var _createHealthRecord = _asyncToGenerator(function* (patientId, providerId, recordType, data, requesterPrivateKey) {\n        if (!this.isInitialized) {\n          throw new Error('Blockchain service not initialized');\n        }\n        try {\n          var recordId = `record_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n          var previousHash = this.blockchain.length > 0 ? this.blockchain[this.blockchain.length - 1].hash : '0';\n          var recordData = {\n            id: recordId,\n            patientId: patientId,\n            providerId: providerId,\n            recordType: recordType,\n            data: data,\n            timestamp: new Date(),\n            previousHash: previousHash\n          };\n          var hash = yield this.cryptoEngine.hashData(recordData);\n          var signature = yield this.cryptoEngine.signData(recordData, requesterPrivateKey);\n          var healthRecord = _objectSpread(_objectSpread({}, recordData), {}, {\n            hash: hash,\n            signature: signature,\n            accessPermissions: [{\n              grantedTo: patientId,\n              permissionType: 'admin',\n              expiresAt: new Date(Date.now() + 10 * 365 * 24 * 60 * 60 * 1000),\n              purpose: 'Patient ownership',\n              consentHash: yield this.cryptoEngine.hashData({\n                patientId: patientId,\n                purpose: 'ownership'\n              })\n            }, {\n              grantedTo: providerId,\n              permissionType: 'write',\n              expiresAt: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000),\n              purpose: 'Healthcare provider access',\n              consentHash: yield this.cryptoEngine.hashData({\n                providerId: providerId,\n                purpose: 'treatment'\n              })\n            }]\n          });\n          this.blockchain.push(healthRecord);\n          this.healthRecords.set(recordId, healthRecord);\n          yield this.logAudit('create', recordId, providerId, true);\n          console.log(`üìù Health record created: ${recordId}`);\n          return recordId;\n        } catch (error) {\n          console.error('‚ùå Failed to create health record:', error);\n          throw error;\n        }\n      });\n      function createHealthRecord(_x13, _x14, _x15, _x16, _x17) {\n        return _createHealthRecord.apply(this, arguments);\n      }\n      return createHealthRecord;\n    }())\n  }, {\n    key: \"getHealthRecord\",\n    value: (function () {\n      var _getHealthRecord = _asyncToGenerator(function* (recordId, requesterId) {\n        if (!this.isInitialized) {\n          throw new Error('Blockchain service not initialized');\n        }\n        try {\n          var record = this.healthRecords.get(recordId);\n          if (!record) {\n            yield this.logAudit('read', recordId, requesterId, false, 'Record not found');\n            return null;\n          }\n          var hasAccess = yield this.checkAccess(record, requesterId, 'read');\n          if (!hasAccess) {\n            yield this.logAudit('read', recordId, requesterId, false, 'Access denied');\n            throw new Error('Access denied');\n          }\n          yield this.logAudit('read', recordId, requesterId, true);\n          return record;\n        } catch (error) {\n          console.error('‚ùå Failed to retrieve health record:', error);\n          throw error;\n        }\n      });\n      function getHealthRecord(_x18, _x19) {\n        return _getHealthRecord.apply(this, arguments);\n      }\n      return getHealthRecord;\n    }())\n  }, {\n    key: \"grantConsent\",\n    value: (function () {\n      var _grantConsent = _asyncToGenerator(function* (patientId, providerId, dataTypes, permissions, purpose, expiresAt, patientPrivateKey) {\n        if (!this.isInitialized) {\n          throw new Error('Blockchain service not initialized');\n        }\n        try {\n          var consentId = `consent_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n          var consentData = {\n            id: consentId,\n            patientId: patientId,\n            providerId: providerId,\n            dataTypes: dataTypes,\n            permissions: permissions,\n            grantedAt: new Date(),\n            expiresAt: expiresAt,\n            purpose: purpose,\n            legalBasis: 'Patient consent'\n          };\n          var contractResult = yield this.contractEngine.executeContract('consent_contract', _objectSpread({\n            action: 'grant'\n          }, consentData));\n          if (!contractResult.success) {\n            throw new Error('Consent contract execution failed');\n          }\n          var consentRecord = _objectSpread(_objectSpread({}, consentData), {}, {\n            isRevoked: false\n          });\n          this.consentRecords.set(consentId, consentRecord);\n          yield this.logAudit('create', consentId, patientId, true, 'Consent granted');\n          console.log(`‚úÖ Consent granted: ${consentId}`);\n          return consentId;\n        } catch (error) {\n          console.error('‚ùå Failed to grant consent:', error);\n          throw error;\n        }\n      });\n      function grantConsent(_x20, _x21, _x22, _x23, _x24, _x25, _x26) {\n        return _grantConsent.apply(this, arguments);\n      }\n      return grantConsent;\n    }())\n  }, {\n    key: \"revokeConsent\",\n    value: (function () {\n      var _revokeConsent = _asyncToGenerator(function* (consentId, patientId, reason) {\n        if (!this.isInitialized) {\n          throw new Error('Blockchain service not initialized');\n        }\n        try {\n          var consentRecord = this.consentRecords.get(consentId);\n          if (!consentRecord) {\n            throw new Error('Consent record not found');\n          }\n          if (consentRecord.patientId !== patientId) {\n            throw new Error('Unauthorized to revoke this consent');\n          }\n          var contractResult = yield this.contractEngine.executeContract('consent_contract', {\n            action: 'revoke',\n            consentId: consentId,\n            reason: reason\n          });\n          if (!contractResult.success) {\n            throw new Error('Consent revocation contract execution failed');\n          }\n          consentRecord.isRevoked = true;\n          consentRecord.revokedAt = new Date();\n          this.consentRecords.set(consentId, consentRecord);\n          yield this.logAudit('update', consentId, patientId, true, `Consent revoked: ${reason}`);\n          console.log(`üö´ Consent revoked: ${consentId}`);\n        } catch (error) {\n          console.error('‚ùå Failed to revoke consent:', error);\n          throw error;\n        }\n      });\n      function revokeConsent(_x27, _x28, _x29) {\n        return _revokeConsent.apply(this, arguments);\n      }\n      return revokeConsent;\n    }())\n  }, {\n    key: \"checkAccess\",\n    value: (function () {\n      var _checkAccess = _asyncToGenerator(function* (record, requesterId, action) {\n        var permission = record.accessPermissions.find(function (p) {\n          return p.grantedTo === requesterId && (p.permissionType === action || p.permissionType === 'admin') && p.expiresAt > new Date();\n        });\n        if (permission) {\n          return true;\n        }\n        var relevantConsents = Array.from(this.consentRecords.values()).filter(function (consent) {\n          return consent.patientId === record.patientId && consent.providerId === requesterId && !consent.isRevoked && consent.expiresAt > new Date() && consent.permissions.includes(action);\n        });\n        return relevantConsents.length > 0;\n      });\n      function checkAccess(_x30, _x31, _x32) {\n        return _checkAccess.apply(this, arguments);\n      }\n      return checkAccess;\n    }())\n  }, {\n    key: \"logAudit\",\n    value: (function () {\n      var _logAudit = _asyncToGenerator(function* (action, recordId, userId, success, reason) {\n        var auditLog = {\n          id: `audit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n          action: action,\n          recordId: recordId,\n          userId: userId,\n          timestamp: new Date(),\n          ipAddress: '127.0.0.1',\n          userAgent: 'MediMind-App',\n          success: success,\n          reason: reason\n        };\n        this.auditLogs.push(auditLog);\n        yield this.contractEngine.executeContract('audit_contract', auditLog);\n      });\n      function logAudit(_x33, _x34, _x35, _x36, _x37) {\n        return _logAudit.apply(this, arguments);\n      }\n      return logAudit;\n    }())\n  }, {\n    key: \"getAuditLogs\",\n    value: (function () {\n      var _getAuditLogs = _asyncToGenerator(function* (recordId, requesterId) {\n        if (!this.isInitialized) {\n          throw new Error('Blockchain service not initialized');\n        }\n        var record = this.healthRecords.get(recordId);\n        if (!record) {\n          throw new Error('Record not found');\n        }\n        var hasAdminAccess = yield this.checkAccess(record, requesterId, 'read');\n        if (!hasAdminAccess && record.patientId !== requesterId) {\n          throw new Error('Insufficient permissions to view audit logs');\n        }\n        return this.auditLogs.filter(function (log) {\n          return log.recordId === recordId;\n        });\n      });\n      function getAuditLogs(_x38, _x39) {\n        return _getAuditLogs.apply(this, arguments);\n      }\n      return getAuditLogs;\n    }())\n  }, {\n    key: \"verifyBlockchainIntegrity\",\n    value: (function () {\n      var _verifyBlockchainIntegrity = _asyncToGenerator(function* () {\n        var errors = [];\n        for (var i = 1; i < this.blockchain.length; i++) {\n          var currentBlock = this.blockchain[i];\n          var previousBlock = this.blockchain[i - 1];\n          if (currentBlock.previousHash !== previousBlock.hash) {\n            errors.push(`Block ${i}: Previous hash mismatch`);\n          }\n          var expectedHash = yield this.cryptoEngine.hashData({\n            id: currentBlock.id,\n            patientId: currentBlock.patientId,\n            providerId: currentBlock.providerId,\n            recordType: currentBlock.recordType,\n            data: currentBlock.data,\n            timestamp: currentBlock.timestamp,\n            previousHash: currentBlock.previousHash\n          });\n          if (currentBlock.hash !== expectedHash) {\n            errors.push(`Block ${i}: Hash verification failed`);\n          }\n        }\n        return {\n          isValid: errors.length === 0,\n          errors: errors\n        };\n      });\n      function verifyBlockchainIntegrity() {\n        return _verifyBlockchainIntegrity.apply(this, arguments);\n      }\n      return verifyBlockchainIntegrity;\n    }())\n  }, {\n    key: \"getBlockchainStats\",\n    value: function getBlockchainStats() {\n      return {\n        totalBlocks: this.blockchain.length,\n        totalRecords: this.healthRecords.size,\n        totalConsents: this.consentRecords.size,\n        totalAuditLogs: this.auditLogs.length,\n        activeConsents: Array.from(this.consentRecords.values()).filter(function (c) {\n          return !c.isRevoked && c.expiresAt > new Date();\n        }).length,\n        lastBlockTimestamp: this.blockchain.length > 0 ? this.blockchain[this.blockchain.length - 1].timestamp : null\n      };\n    }\n  }], [{\n    key: \"getInstance\",\n    value: function getInstance() {\n      if (!HealthDataBlockchainService.instance) {\n        HealthDataBlockchainService.instance = new HealthDataBlockchainService();\n      }\n      return HealthDataBlockchainService.instance;\n    }\n  }, {\n    key: \"initialize\",\n    value: function () {\n      var _initialize2 = _asyncToGenerator(function* () {\n        var instance = HealthDataBlockchainService.getInstance();\n        yield instance.initialize();\n      });\n      function initialize() {\n        return _initialize2.apply(this, arguments);\n      }\n      return initialize;\n    }()\n  }]);\n}();","map":{"version":3,"names":["CryptographicEngine","_classCallCheck","keyPairs","Map","_createClass","key","value","_generateKeyPair","_asyncToGenerator","userId","keyPair","publicKey","Date","now","privateKey","set","console","log","generateKeyPair","_x","apply","arguments","_signData","data","dataString","JSON","stringify","signature","btoa","signData","_x2","_x3","_verifySignature","decodedSig","atob","includes","replace","verifySignature","_x4","_x5","_x6","_hashData","hash","i","length","char","charCodeAt","Math","abs","toString","hashData","_x7","_encryptData","encryptData","_x8","_x9","_decryptData","encryptedData","decoded","parts","split","slice","join","parse","Error","decryptData","_x0","_x1","SmartContractEngine","contracts","contractExecutions","_deployContract","contract","contractId","random","substr","deployedContract","_objectSpread","id","deployedAt","type","deployContract","_x10","_executeContract","params","get","isActive","execution","timestamp","result","simulateContractExecution","executions","push","executeContract","_x11","_x12","executeConsentContract","executeAccessControlContract","executeDataSharingContract","executeAuditContract","success","error","action","consentId","grantedAt","expiresAt","revokedAt","reason","hasPermission","accessGranted","sharingId","sharedWith","recipient","dataTypes","purpose","auditId","logged","getContract","getContractExecutions","HealthDataBlockchainService","isInitialized","cryptoEngine","contractEngine","healthRecords","consentRecords","auditLogs","blockchain","_initialize","deployConsentContract","deployAccessControlContract","deployDataSharingContract","deployAuditContract","createGenesisBlock","initialize","_deployConsentContract","code","owner","_deployAccessControlContract","_deployDataSharingContract","_deployAuditContract","_createGenesisBlock","genesisRecord","patientId","providerId","recordType","message","previousHash","accessPermissions","_createHealthRecord","requesterPrivateKey","recordId","recordData","healthRecord","grantedTo","permissionType","consentHash","logAudit","createHealthRecord","_x13","_x14","_x15","_x16","_x17","_getHealthRecord","requesterId","record","hasAccess","checkAccess","getHealthRecord","_x18","_x19","_grantConsent","permissions","patientPrivateKey","consentData","legalBasis","contractResult","consentRecord","isRevoked","grantConsent","_x20","_x21","_x22","_x23","_x24","_x25","_x26","_revokeConsent","revokeConsent","_x27","_x28","_x29","_checkAccess","permission","find","p","relevantConsents","Array","from","values","filter","consent","_x30","_x31","_x32","_logAudit","auditLog","ipAddress","userAgent","_x33","_x34","_x35","_x36","_x37","_getAuditLogs","hasAdminAccess","getAuditLogs","_x38","_x39","_verifyBlockchainIntegrity","errors","currentBlock","previousBlock","expectedHash","isValid","verifyBlockchainIntegrity","getBlockchainStats","totalBlocks","totalRecords","size","totalConsents","totalAuditLogs","activeConsents","c","lastBlockTimestamp","getInstance","instance","_initialize2"],"sources":["/Users/theophilusogieva/Desktop/MediMindPlus/MediMindPlus/frontend/src/services/blockchain/healthDataBlockchain.ts"],"sourcesContent":["/**\n * Blockchain-based Health Data Management Service\n * Implements secure, immutable health records with smart contracts\n */\n\ninterface HealthRecord {\n  id: string;\n  patientId: string;\n  providerId: string;\n  recordType: 'vital_signs' | 'diagnosis' | 'prescription' | 'lab_result' | 'imaging';\n  data: any;\n  timestamp: Date;\n  hash: string;\n  previousHash: string;\n  signature: string;\n  accessPermissions: AccessPermission[];\n}\n\ninterface AccessPermission {\n  grantedTo: string; // Provider ID or patient ID\n  permissionType: 'read' | 'write' | 'admin';\n  expiresAt: Date;\n  purpose: string;\n  consentHash: string;\n}\n\ninterface SmartContract {\n  id: string;\n  type: 'consent' | 'access_control' | 'data_sharing' | 'audit';\n  code: string;\n  deployedAt: Date;\n  owner: string;\n  isActive: boolean;\n}\n\ninterface ConsentRecord {\n  id: string;\n  patientId: string;\n  providerId: string;\n  dataTypes: string[];\n  permissions: string[];\n  grantedAt: Date;\n  expiresAt: Date;\n  isRevoked: boolean;\n  revokedAt?: Date;\n  purpose: string;\n  legalBasis: string;\n}\n\ninterface AuditLog {\n  id: string;\n  action: 'create' | 'read' | 'update' | 'delete' | 'share';\n  recordId: string;\n  userId: string;\n  timestamp: Date;\n  ipAddress: string;\n  userAgent: string;\n  success: boolean;\n  reason?: string;\n}\n\nclass CryptographicEngine {\n  private keyPairs: Map<string, { publicKey: string; privateKey: string }> = new Map();\n\n  async generateKeyPair(userId: string): Promise<{ publicKey: string; privateKey: string }> {\n    // Simulate key generation (in real implementation would use Web Crypto API)\n    const keyPair = {\n      publicKey: `pub_${userId}_${Date.now()}`,\n      privateKey: `priv_${userId}_${Date.now()}`\n    };\n    \n    this.keyPairs.set(userId, keyPair);\n    console.log(`üîë Generated key pair for user: ${userId}`);\n    \n    return keyPair;\n  }\n\n  async signData(data: any, privateKey: string): Promise<string> {\n    // Simulate digital signature (in real implementation would use ECDSA)\n    const dataString = JSON.stringify(data);\n    const signature = btoa(`${privateKey}_${dataString}_${Date.now()}`);\n    return signature;\n  }\n\n  async verifySignature(data: any, signature: string, publicKey: string): Promise<boolean> {\n    // Simulate signature verification\n    const dataString = JSON.stringify(data);\n    const decodedSig = atob(signature);\n    return decodedSig.includes(publicKey.replace('pub_', 'priv_'));\n  }\n\n  async hashData(data: any): Promise<string> {\n    // Simulate SHA-256 hashing (in real implementation would use Web Crypto API)\n    const dataString = JSON.stringify(data);\n    let hash = 0;\n    for (let i = 0; i < dataString.length; i++) {\n      const char = dataString.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return Math.abs(hash).toString(16);\n  }\n\n  async encryptData(data: any, publicKey: string): Promise<string> {\n    // Simulate encryption (in real implementation would use RSA/AES)\n    const dataString = JSON.stringify(data);\n    return btoa(`${publicKey}_${dataString}`);\n  }\n\n  async decryptData(encryptedData: string, privateKey: string): Promise<any> {\n    // Simulate decryption\n    const decoded = atob(encryptedData);\n    const parts = decoded.split('_');\n    if (parts.length >= 2) {\n      const dataString = parts.slice(1).join('_');\n      return JSON.parse(dataString);\n    }\n    throw new Error('Decryption failed');\n  }\n}\n\nclass SmartContractEngine {\n  private contracts: Map<string, SmartContract> = new Map();\n  private contractExecutions: Map<string, any[]> = new Map();\n\n  async deployContract(contract: Omit<SmartContract, 'id' | 'deployedAt'>): Promise<string> {\n    const contractId = `contract_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    const deployedContract: SmartContract = {\n      ...contract,\n      id: contractId,\n      deployedAt: new Date()\n    };\n    \n    this.contracts.set(contractId, deployedContract);\n    console.log(`üìú Smart contract deployed: ${contractId} (${contract.type})`);\n    \n    return contractId;\n  }\n\n  async executeContract(contractId: string, params: any): Promise<any> {\n    const contract = this.contracts.get(contractId);\n    \n    if (!contract || !contract.isActive) {\n      throw new Error('Contract not found or inactive');\n    }\n    \n    // Simulate contract execution\n    const execution = {\n      contractId,\n      params,\n      timestamp: new Date(),\n      result: this.simulateContractExecution(contract, params)\n    };\n    \n    const executions = this.contractExecutions.get(contractId) || [];\n    executions.push(execution);\n    this.contractExecutions.set(contractId, executions);\n    \n    console.log(`‚ö° Contract executed: ${contractId}`);\n    return execution.result;\n  }\n\n  private simulateContractExecution(contract: SmartContract, params: any): any {\n    switch (contract.type) {\n      case 'consent':\n        return this.executeConsentContract(params);\n      case 'access_control':\n        return this.executeAccessControlContract(params);\n      case 'data_sharing':\n        return this.executeDataSharingContract(params);\n      case 'audit':\n        return this.executeAuditContract(params);\n      default:\n        return { success: false, error: 'Unknown contract type' };\n    }\n  }\n\n  private executeConsentContract(params: any): any {\n    // Simulate consent management logic\n    if (params.action === 'grant') {\n      return {\n        success: true,\n        consentId: `consent_${Date.now()}`,\n        grantedAt: new Date(),\n        expiresAt: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000) // 1 year\n      };\n    } else if (params.action === 'revoke') {\n      return {\n        success: true,\n        revokedAt: new Date(),\n        reason: params.reason || 'Patient request'\n      };\n    }\n    return { success: false, error: 'Invalid consent action' };\n  }\n\n  private executeAccessControlContract(params: any): any {\n    // Simulate access control logic\n    const hasPermission = Math.random() > 0.1; // 90% success rate for demo\n    \n    return {\n      success: hasPermission,\n      accessGranted: hasPermission,\n      reason: hasPermission ? 'Access granted' : 'Insufficient permissions',\n      timestamp: new Date()\n    };\n  }\n\n  private executeDataSharingContract(params: any): any {\n    // Simulate data sharing logic\n    return {\n      success: true,\n      sharingId: `share_${Date.now()}`,\n      sharedWith: params.recipient,\n      dataTypes: params.dataTypes,\n      purpose: params.purpose,\n      expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 days\n    };\n  }\n\n  private executeAuditContract(params: any): any {\n    // Simulate audit logging\n    return {\n      success: true,\n      auditId: `audit_${Date.now()}`,\n      action: params.action,\n      timestamp: new Date(),\n      logged: true\n    };\n  }\n\n  getContract(contractId: string): SmartContract | undefined {\n    return this.contracts.get(contractId);\n  }\n\n  getContractExecutions(contractId: string): any[] {\n    return this.contractExecutions.get(contractId) || [];\n  }\n}\n\nexport class HealthDataBlockchainService {\n  private static instance: HealthDataBlockchainService;\n  private isInitialized = false;\n  private cryptoEngine: CryptographicEngine = new CryptographicEngine();\n  private contractEngine: SmartContractEngine = new SmartContractEngine();\n  private healthRecords: Map<string, HealthRecord> = new Map();\n  private consentRecords: Map<string, ConsentRecord> = new Map();\n  private auditLogs: AuditLog[] = [];\n  private blockchain: HealthRecord[] = []; // Simplified blockchain structure\n\n  static getInstance(): HealthDataBlockchainService {\n    if (!HealthDataBlockchainService.instance) {\n      HealthDataBlockchainService.instance = new HealthDataBlockchainService();\n    }\n    return HealthDataBlockchainService.instance;\n  }\n\n  static async initialize(): Promise<void> {\n    const instance = HealthDataBlockchainService.getInstance();\n    await instance.initialize();\n  }\n\n  async initialize(): Promise<void> {\n    try {\n      console.log('üîó Initializing Blockchain Health Data Management...');\n      \n      // Deploy core smart contracts\n      await this.deployConsentContract();\n      await this.deployAccessControlContract();\n      await this.deployDataSharingContract();\n      await this.deployAuditContract();\n      \n      // Initialize genesis block\n      await this.createGenesisBlock();\n      \n      this.isInitialized = true;\n      console.log('‚úÖ Blockchain Health Data Management initialized successfully');\n      \n    } catch (error) {\n      console.error('‚ùå Failed to initialize Blockchain Health Data Management:', error);\n      throw error;\n    }\n  }\n\n  private async deployConsentContract(): Promise<void> {\n    await this.contractEngine.deployContract({\n      type: 'consent',\n      code: 'consent_management_v1',\n      owner: 'system',\n      isActive: true\n    });\n  }\n\n  private async deployAccessControlContract(): Promise<void> {\n    await this.contractEngine.deployContract({\n      type: 'access_control',\n      code: 'access_control_v1',\n      owner: 'system',\n      isActive: true\n    });\n  }\n\n  private async deployDataSharingContract(): Promise<void> {\n    await this.contractEngine.deployContract({\n      type: 'data_sharing',\n      code: 'data_sharing_v1',\n      owner: 'system',\n      isActive: true\n    });\n  }\n\n  private async deployAuditContract(): Promise<void> {\n    await this.contractEngine.deployContract({\n      type: 'audit',\n      code: 'audit_logging_v1',\n      owner: 'system',\n      isActive: true\n    });\n  }\n\n  private async createGenesisBlock(): Promise<void> {\n    const genesisRecord: HealthRecord = {\n      id: 'genesis',\n      patientId: 'system',\n      providerId: 'system',\n      recordType: 'vital_signs',\n      data: { message: 'MediMind Blockchain Genesis Block' },\n      timestamp: new Date(),\n      hash: await this.cryptoEngine.hashData('genesis'),\n      previousHash: '0',\n      signature: 'genesis_signature',\n      accessPermissions: []\n    };\n\n    this.blockchain.push(genesisRecord);\n    console.log('üéØ Genesis block created');\n  }\n\n  /**\n   * Create a new health record on the blockchain\n   */\n  async createHealthRecord(\n    patientId: string,\n    providerId: string,\n    recordType: HealthRecord['recordType'],\n    data: any,\n    requesterPrivateKey: string\n  ): Promise<string> {\n    if (!this.isInitialized) {\n      throw new Error('Blockchain service not initialized');\n    }\n\n    try {\n      // Generate record ID\n      const recordId = `record_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n      // Get previous block hash\n      const previousHash = this.blockchain.length > 0\n        ? this.blockchain[this.blockchain.length - 1].hash\n        : '0';\n\n      // Create record data\n      const recordData = {\n        id: recordId,\n        patientId,\n        providerId,\n        recordType,\n        data,\n        timestamp: new Date(),\n        previousHash\n      };\n\n      // Generate hash and signature\n      const hash = await this.cryptoEngine.hashData(recordData);\n      const signature = await this.cryptoEngine.signData(recordData, requesterPrivateKey);\n\n      // Create health record\n      const healthRecord: HealthRecord = {\n        ...recordData,\n        hash,\n        signature,\n        accessPermissions: [\n          {\n            grantedTo: patientId,\n            permissionType: 'admin',\n            expiresAt: new Date(Date.now() + 10 * 365 * 24 * 60 * 60 * 1000), // 10 years\n            purpose: 'Patient ownership',\n            consentHash: await this.cryptoEngine.hashData({ patientId, purpose: 'ownership' })\n          },\n          {\n            grantedTo: providerId,\n            permissionType: 'write',\n            expiresAt: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), // 1 year\n            purpose: 'Healthcare provider access',\n            consentHash: await this.cryptoEngine.hashData({ providerId, purpose: 'treatment' })\n          }\n        ]\n      };\n\n      // Add to blockchain\n      this.blockchain.push(healthRecord);\n      this.healthRecords.set(recordId, healthRecord);\n\n      // Log audit trail\n      await this.logAudit('create', recordId, providerId, true);\n\n      console.log(`üìù Health record created: ${recordId}`);\n      return recordId;\n\n    } catch (error) {\n      console.error('‚ùå Failed to create health record:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieve health record with access control\n   */\n  async getHealthRecord(recordId: string, requesterId: string): Promise<HealthRecord | null> {\n    if (!this.isInitialized) {\n      throw new Error('Blockchain service not initialized');\n    }\n\n    try {\n      const record = this.healthRecords.get(recordId);\n\n      if (!record) {\n        await this.logAudit('read', recordId, requesterId, false, 'Record not found');\n        return null;\n      }\n\n      // Check access permissions\n      const hasAccess = await this.checkAccess(record, requesterId, 'read');\n\n      if (!hasAccess) {\n        await this.logAudit('read', recordId, requesterId, false, 'Access denied');\n        throw new Error('Access denied');\n      }\n\n      // Log successful access\n      await this.logAudit('read', recordId, requesterId, true);\n\n      return record;\n\n    } catch (error) {\n      console.error('‚ùå Failed to retrieve health record:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Grant consent for data access\n   */\n  async grantConsent(\n    patientId: string,\n    providerId: string,\n    dataTypes: string[],\n    permissions: string[],\n    purpose: string,\n    expiresAt: Date,\n    patientPrivateKey: string\n  ): Promise<string> {\n    if (!this.isInitialized) {\n      throw new Error('Blockchain service not initialized');\n    }\n\n    try {\n      const consentId = `consent_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n      const consentData = {\n        id: consentId,\n        patientId,\n        providerId,\n        dataTypes,\n        permissions,\n        grantedAt: new Date(),\n        expiresAt,\n        purpose,\n        legalBasis: 'Patient consent'\n      };\n\n      // Execute consent smart contract\n      const contractResult = await this.contractEngine.executeContract('consent_contract', {\n        action: 'grant',\n        ...consentData\n      });\n\n      if (!contractResult.success) {\n        throw new Error('Consent contract execution failed');\n      }\n\n      // Create consent record\n      const consentRecord: ConsentRecord = {\n        ...consentData,\n        isRevoked: false\n      };\n\n      this.consentRecords.set(consentId, consentRecord);\n\n      // Log audit trail\n      await this.logAudit('create', consentId, patientId, true, 'Consent granted');\n\n      console.log(`‚úÖ Consent granted: ${consentId}`);\n      return consentId;\n\n    } catch (error) {\n      console.error('‚ùå Failed to grant consent:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Revoke consent\n   */\n  async revokeConsent(consentId: string, patientId: string, reason: string): Promise<void> {\n    if (!this.isInitialized) {\n      throw new Error('Blockchain service not initialized');\n    }\n\n    try {\n      const consentRecord = this.consentRecords.get(consentId);\n\n      if (!consentRecord) {\n        throw new Error('Consent record not found');\n      }\n\n      if (consentRecord.patientId !== patientId) {\n        throw new Error('Unauthorized to revoke this consent');\n      }\n\n      // Execute consent revocation contract\n      const contractResult = await this.contractEngine.executeContract('consent_contract', {\n        action: 'revoke',\n        consentId,\n        reason\n      });\n\n      if (!contractResult.success) {\n        throw new Error('Consent revocation contract execution failed');\n      }\n\n      // Update consent record\n      consentRecord.isRevoked = true;\n      consentRecord.revokedAt = new Date();\n      this.consentRecords.set(consentId, consentRecord);\n\n      // Log audit trail\n      await this.logAudit('update', consentId, patientId, true, `Consent revoked: ${reason}`);\n\n      console.log(`üö´ Consent revoked: ${consentId}`);\n\n    } catch (error) {\n      console.error('‚ùå Failed to revoke consent:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Check access permissions\n   */\n  private async checkAccess(record: HealthRecord, requesterId: string, action: 'read' | 'write'): Promise<boolean> {\n    // Check direct permissions\n    const permission = record.accessPermissions.find(p =>\n      p.grantedTo === requesterId &&\n      (p.permissionType === action || p.permissionType === 'admin') &&\n      p.expiresAt > new Date()\n    );\n\n    if (permission) {\n      return true;\n    }\n\n    // Check consent-based permissions\n    const relevantConsents = Array.from(this.consentRecords.values()).filter(consent =>\n      consent.patientId === record.patientId &&\n      consent.providerId === requesterId &&\n      !consent.isRevoked &&\n      consent.expiresAt > new Date() &&\n      consent.permissions.includes(action)\n    );\n\n    return relevantConsents.length > 0;\n  }\n\n  /**\n   * Log audit trail\n   */\n  private async logAudit(\n    action: AuditLog['action'],\n    recordId: string,\n    userId: string,\n    success: boolean,\n    reason?: string\n  ): Promise<void> {\n    const auditLog: AuditLog = {\n      id: `audit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      action,\n      recordId,\n      userId,\n      timestamp: new Date(),\n      ipAddress: '127.0.0.1', // Would be actual IP in real implementation\n      userAgent: 'MediMind-App',\n      success,\n      reason\n    };\n\n    this.auditLogs.push(auditLog);\n\n    // Execute audit smart contract\n    await this.contractEngine.executeContract('audit_contract', auditLog);\n  }\n\n  /**\n   * Get audit logs for a record\n   */\n  async getAuditLogs(recordId: string, requesterId: string): Promise<AuditLog[]> {\n    if (!this.isInitialized) {\n      throw new Error('Blockchain service not initialized');\n    }\n\n    // Check if requester has admin access to the record\n    const record = this.healthRecords.get(recordId);\n    if (!record) {\n      throw new Error('Record not found');\n    }\n\n    const hasAdminAccess = await this.checkAccess(record, requesterId, 'read');\n    if (!hasAdminAccess && record.patientId !== requesterId) {\n      throw new Error('Insufficient permissions to view audit logs');\n    }\n\n    return this.auditLogs.filter(log => log.recordId === recordId);\n  }\n\n  /**\n   * Verify blockchain integrity\n   */\n  async verifyBlockchainIntegrity(): Promise<{ isValid: boolean; errors: string[] }> {\n    const errors: string[] = [];\n\n    for (let i = 1; i < this.blockchain.length; i++) {\n      const currentBlock = this.blockchain[i];\n      const previousBlock = this.blockchain[i - 1];\n\n      // Verify previous hash\n      if (currentBlock.previousHash !== previousBlock.hash) {\n        errors.push(`Block ${i}: Previous hash mismatch`);\n      }\n\n      // Verify current hash\n      const expectedHash = await this.cryptoEngine.hashData({\n        id: currentBlock.id,\n        patientId: currentBlock.patientId,\n        providerId: currentBlock.providerId,\n        recordType: currentBlock.recordType,\n        data: currentBlock.data,\n        timestamp: currentBlock.timestamp,\n        previousHash: currentBlock.previousHash\n      });\n\n      if (currentBlock.hash !== expectedHash) {\n        errors.push(`Block ${i}: Hash verification failed`);\n      }\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors\n    };\n  }\n\n  /**\n   * Get blockchain statistics\n   */\n  getBlockchainStats(): any {\n    return {\n      totalBlocks: this.blockchain.length,\n      totalRecords: this.healthRecords.size,\n      totalConsents: this.consentRecords.size,\n      totalAuditLogs: this.auditLogs.length,\n      activeConsents: Array.from(this.consentRecords.values()).filter(c => !c.isRevoked && c.expiresAt > new Date()).length,\n      lastBlockTimestamp: this.blockchain.length > 0 ? this.blockchain[this.blockchain.length - 1].timestamp : null\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}